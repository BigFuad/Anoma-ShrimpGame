<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Anoma Shrimp Game</title>
<style>
  :root{
    --bg:#000;
    --text:#eef2ff;
    --muted:#a9b6df;
    --red:#e11937;
    --glow:rgba(255,48,64,0.35);
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;}
  .screen{width:100%;max-width:1100px;margin:0 auto;box-sizing:border-box}
  /* Landing */
  #landing{height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:18px;text-align:center;position:relative}
  .title-wrap{overflow:hidden;width:100%;max-width:900px}
  .title{
    display:inline-block;
    white-space:nowrap;
    font-weight:800;
    font-size:clamp(20px,3.6vw,40px);
    letter-spacing:.6px;
    color:var(--text);
    transform:translateX(-120%);
    animation: slideLR 9s linear infinite;
  }
  .title .brand{ color:var(--red); }
  @keyframes slideLR{
    0%{ transform: translateX(-120%); }
    100%{ transform: translateX(120%); }
  }

  /* Landing mage image */
  #landing .mage {
    width:min(360px,42vw);
    max-width:420px;
    height:auto;
    object-fit:contain;
    display:block;
    margin:0 auto;
  }

  /* Controls on landing */
  .controls-row{display:flex;gap:12px;align-items:center;justify-content:center;flex-wrap:wrap}
  select, button { font-family:inherit }

  #level-select{
    padding:10px 12px;
    border-radius:10px;
    background:transparent;
    color:var(--text);
    border:1px solid rgba(255,255,255,0.06);
  }

  #btn-play {
    background:linear-gradient(180deg,var(--red),#bf0f2a);
    color:white;
    border:0;
    padding:12px 20px;
    border-radius:12px;
    font-weight:700;
    cursor:pointer;
    font-size:1rem;
    box-shadow:0 6px 20px rgba(225,25,55,0.18);
  }
  #btn-play:active{ transform:translateY(1px) }

  /* Game screen */
  #game-screen{display:none;min-height:100vh;position:relative;padding:14px 10px 90px; box-sizing:border-box;}
  .hud{display:flex;gap:12px;justify-content:center;align-items:center;margin-bottom:8px;color:var(--muted);font-weight:600}
  .hud div{min-width:90px;text-align:center}

  /* Canvas center */
  .stage{display:flex;align-items:center;justify-content:center}
  canvas{background:var(--bg);display:block;border-radius:8px;touch-action:none;outline:0}

  /* D-pad large & centered */
  .dpad {
    position:fixed;
    left:50%;
    transform:translateX(-50%);
    bottom:18px;
    display:grid;
    gap:10px;
    grid-template-columns:repeat(3, auto);
    grid-template-rows: auto auto;
    justify-items:center;
    z-index:40;
  }
  .dpad button {
    width:96px; height:96px;
    border-radius:14px; border:0;
    font-size:34px; font-weight:700;
    background:#111; color:white;
    box-shadow:0 6px 20px rgba(0,0,0,0.6), 0 0 18px 2px var(--glow);
    display:inline-grid; place-items:center;
    cursor:pointer;
    user-select:none;
    -webkit-tap-highlight-color: transparent;
    transition:transform .08s, box-shadow .12s;
  }
  .dpad button:active{ transform:scale(.97); box-shadow:0 0 30px 4px var(--glow) }

  /* grid placement */
  .dpad .up{ grid-column:2; grid-row:1 }
  .dpad .left{ grid-column:1; grid-row:2 }
  .dpad .down{ grid-column:2; grid-row:2 }
  .dpad .right{ grid-column:3; grid-row:2 }

  /* Win modal */
  .win-modal {
    position:fixed; inset:0;
    display:none; align-items:center; justify-content:center;
    background:rgba(0,0,0,0.85); z-index:80; color:var(--text);
  }
  .win-box{
    background:#0b0f14; border-radius:12px; padding:18px 22px; text-align:center; max-width:520px; width:90%;
    box-shadow:0 10px 50px rgba(0,0,0,0.6);
  }
  .cheer-row{display:flex;gap:12px;align-items:center;justify-content:center;margin-bottom:6px}
  .cheer-row img{width:72px;height:auto;border-radius:10px;filter:drop-shadow(0 6px 20px rgba(225,25,55,0.18))}
  .win-actions{display:flex;gap:8px;justify-content:center;margin-top:10px}
  .btn{padding:8px 14px;border-radius:10px;border:0;cursor:pointer}
  .btn-red{background:linear-gradient(180deg,var(--red),#bf0f2a);color:#fff}
  .btn-ghost{background:transparent;color:var(--text);border:1px solid rgba(255,255,255,0.08)}

  /* Footer fixed and visible on both screens */
  footer { position:fixed; bottom:8px; left:0; right:0; text-align:center; font-size:14px; z-index:90 }
  footer a{ color:var(--red); text-decoration:none; font-weight:700 }

  /* Responsive tweaks */
  @media (max-width:640px){
    .dpad button { width:84px; height:84px; font-size:28px }
    .cheer-row img{width:54px}
  }
</style>
</head>
<body>

<!-- Landing -->
<section id="landing" class="screen">
  <div class="title-wrap" aria-hidden="false">
    <div class="title">Welcome to the <span class="brand">Anoma</span> Shrimp Game</div>
  </div>

  <!-- Replace this image with your mage.png in same folder -->
  <img class="mage" src="mage.png" alt="Shadow Mage Mascot (provide mage.png)">
  <div class="controls-row">
    <label style="color:var(--muted);font-weight:700;margin-right:6px">Difficulty</label>
    <select id="levelSelect" aria-label="Difficulty selector"></select>
  </div>

  <div style="margin-top:8px">
    <button id="playBtn" aria-label="Play" title="Play" >Play ▶</button>
  </div>
</section>

<!-- Game Screen -->
<section id="game-screen" class="screen" hidden>
  <div class="hud">
    <div>Level: <span id="hud-level">1</span></div>
    <div>Time: <span id="hud-time">0.0</span>s</div>
    <div>Size: <span id="hud-size">0×0</span></div>
    <div><button id="btn-restart" class="btn btn-ghost">Restart</button></div>
    <div><button id="btn-exit" class="btn btn-ghost">Exit</button></div>
  </div>

  <div class="stage">
    <canvas id="maze" width="800" height="800" aria-label="Maze canvas"></canvas>
  </div>
</section>

<!-- Large centered D-pad -->
<div class="dpad" aria-hidden="false" role="group" aria-label="On-screen controls">
  <button class="up" data-dir="up" aria-label="Up">▲</button>
  <button class="left" data-dir="left" aria-label="Left">◀</button>
  <button class="down" data-dir="down" aria-label="Down">▼</button>
  <button class="right" data-dir="right" aria-label="Right">▶</button>
</div>

<!-- Win Modal -->
<div class="win-modal" id="winModal" role="dialog" aria-modal="true">
  <div class="win-box">
    <div class="cheer-row" id="cheerRow">
      <img src="mage.png" alt="" />
      <img src="mage.png" alt="" />
      <img src="mage.png" alt="" />
    </div>
    <h2 style="margin:6px 0">🎉 Congratulations!</h2>
    <p id="winText" style="margin:6px 0">You escaped the maze.</p>
    <div style="font-weight:700">Time: <span id="final-time">0.00</span>s</div>
    <div class="win-actions">
      <button id="btn-play-again" class="btn btn-red">Play Again</button>
      <button id="btn-close-win" class="btn btn-ghost">Close</button>
    </div>
  </div>
</div>

<!-- Footer visible on both screens -->
<footer>
  Built by <a href="https://twitter.com/sherlock_XIX" target="_blank" rel="noopener">@sherlock_XIX</a>
</footer>

<!-- Background music file: place music.mp3 in same folder -->
<audio id="bgm" src="music.mp3" loop preload="auto"></audio>

<script>
/* --------- Config / helpers ---------- */
const levelSelect = document.getElementById('levelSelect');
for(let i=1;i<=20;i++){ levelSelect.add(new Option('Level '+i, String(i))); }
levelSelect.value = "1";

const playBtn = document.getElementById('playBtn');
const landing = document.getElementById('landing');
const gameScreen = document.getElementById('game-screen');
const canvas = document.getElementById('maze');
const ctx = canvas.getContext('2d', { alpha: false });
const hudTime = document.getElementById('hud-time');
const hudLevel = document.getElementById('hud-level');
const hudSize = document.getElementById('hud-size');
const btnRestart = document.getElementById('btn-restart');
const btnExit = document.getElementById('btn-exit');

const bgm = document.getElementById('bgm');

const winModal = document.getElementById('winModal');
const finalTimeEl = document.getElementById('final-time');
const btnPlayAgain = document.getElementById('btn-play-again');
const btnCloseWin = document.getElementById('btn-close-win');

let state = {
  level: 1,
  cols: 11, rows: 11, cell: 32,
  grid: [], // cell objects {c,r,N,E,S,W}
  player: {c:1, r:1},
  start: {c:1,r:1}, end:{c:1,r:1},
  startedAt: 0, animId: 0, finished:false
};

/* level -> maze size mapping (odd sizes) */
function levelToSize(level){
  const min=11, max=45;
  let size = Math.round(min + (max-min)*((level-1)/19));
  if(size % 2 === 0) size++;
  return size;
}

/* create & size canvas responsively */
function setCanvasSize(cols, rows){
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  // available area: width 94% vw, height 70% vh
  const maxSize = Math.min(window.innerWidth * 0.94, window.innerHeight * 0.72);
  const cell = Math.max(6, Math.floor(maxSize / Math.max(cols, rows)));
  state.cell = cell;
  const w = cell * cols, h = cell * rows;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}

/* Recursive backtracker maze generator (grid of cells with walls) */
function genMaze(cols, rows){
  const grid = [];
  for(let r=0;r<rows;r++){
    const row=[];
    for(let c=0;c<cols;c++){
      row.push({c,r, v:false, N:true, E:true, S:true, W:true});
    }
    grid.push(row);
  }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
  const stack = [];
  // start at 1,1 to have outer boundary intact
  let current = grid[1][1]; current.v = true; let visited = 1, total = cols*rows;
  function neighbors(cell){
    const res=[];
    const {c,r}=cell;
    if(r>1) res.push(['N', grid[r-1][c]]);
    if(c<cols-2) res.push(['E', grid[r][c+1]]);
    if(r<rows-2) res.push(['S', grid[r+1][c]]);
    if(c>1) res.push(['W', grid[r][c-1]]);
    return shuffle(res);
  }
  while(visited < total){
    const nbs = neighbors(current).filter(([,n])=>!n.v);
    if(nbs.length>0){
      const [dir, nxt] = nbs[0];
      stack.push(current);
      if(dir==='N'){ current.N=false; nxt.S=false; }
      if(dir==='E'){ current.E=false; nxt.W=false; }
      if(dir==='S'){ current.S=false; nxt.N=false; }
      if(dir==='W'){ current.W=false; nxt.E=false; }
      current = nxt; current.v = true; visited++;
    } else if(stack.length>0){
      current = stack.pop();
    } else break;
  }
  // ensure start/end at opposite corners inside the border
  const start = grid[1][1];
  const end = grid[rows-2][cols-2];
  return {grid, start:{c:start.c,r:start.r}, end:{c:end.c,r:end.r}};
}

/* Draw maze walls as thin red glow lines and the shrimp/goal */
function draw(){
  const cols = state.cols, rows = state.rows, cell = state.cell;
  // background
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // walls - thin red lines with glow
  ctx.lineWidth = Math.max(1, Math.floor(cell * 0.10));
  ctx.strokeStyle = '#ff3040';
  ctx.shadowColor = 'rgba(255,48,64,0.35)';
  ctx.shadowBlur = Math.max(1, Math.floor(cell * 0.35));

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const cellObj = state.grid[r][c];
      const x = c*cell, y = r*cell;
      if(cellObj.N){ ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x+cell, y); ctx.stroke(); }
      if(cellObj.W){ ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y+cell); ctx.stroke(); }
      // draw southern/eastern boundary only on last row/col
      if(r===rows-1 && cellObj.S){ ctx.beginPath(); ctx.moveTo(x, y+cell); ctx.lineTo(x+cell, y+cell); ctx.stroke(); }
      if(c===cols-1 && cellObj.E){ ctx.beginPath(); ctx.moveTo(x+cell, y); ctx.lineTo(x+cell, y+cell); ctx.stroke(); }
    }
  }

  // Goal highlight
  const gx = state.end.c*cell, gy = state.end.r*cell;
  ctx.shadowBlur = Math.floor(cell*0.9);
  ctx.shadowColor = 'rgba(60,255,140,0.35)';
  ctx.fillStyle = 'rgba(60,255,140,0.2)';
  ctx.fillRect(gx+cell*0.18, gy+cell*0.18, cell*0.64, cell*0.64);

  // Shrimp (emoji) drawn with glow
  const px = state.player.c*cell + cell/2;
  const py = state.player.r*cell + cell/2;
  ctx.shadowBlur = Math.floor(cell*0.7);
  ctx.shadowColor = 'rgba(255,48,64,0.35)';
  ctx.font = `${Math.floor(cell*0.72)}px sans-serif`;
  ctx.textAlign = 'center'; ctx.textBaseline='middle';
  ctx.fillText('🦐', px, py);
  // reset shadow
  ctx.shadowBlur = 0;
}

/* Movement rules - check walls */
function canMove(dir){
  const {c,r} = state.player;
  const cellObj = state.grid[r][c];
  if(dir==='up') return !cellObj.N;
  if(dir==='down') return !cellObj.S;
  if(dir==='left') return !cellObj.W;
  if(dir==='right') return !cellObj.E;
  return false;
}
function move(dir){
  if(state.finished) return;
  let {c,r} = state.player;
  if(!canMove(dir)) return;
  if(dir==='up') r--;
  if(dir==='down') r++;
  if(dir==='left') c--;
  if(dir==='right') c++;
  state.player.c = c; state.player.r = r;
  draw();
  checkWin();
}

/* Timer & HUD */
let timerTick = null;
function startTimer(){
  state.startedAt = performance.now();
  hudTime.textContent = '0.0';
  cancelAnimationFrame(state.animId);
  function tick(){
    if(state.finished) return;
    const t = (performance.now() - state.startedAt)/1000;
    hudTime.textContent = t.toFixed(1);
    state.animId = requestAnimationFrame(tick);
  }
  tick();
}

/* check victory */
function checkWin(){
  if(state.player.c === state.end.c && state.player.r === state.end.r){
    state.finished = true;
    const t = (performance.now() - state.startedAt)/1000;
    finalTimeEl.textContent = t.toFixed(2);
    // Show modal
    winModal.style.display = 'flex';
    try{ bgm.pause(); } catch(e){}
  }
}

/* Initialize & start level */
function startLevel(level){
  state.level = level;
  const size = levelToSize(level);
  state.cols = size; state.rows = size;
  const {grid, start, end} = genMaze(size, size);
  state.grid = grid;
  state.start = start; state.end = end;
  state.player = {c:start.c, r:start.r};
  // setup canvas size
  setCanvasSize(size, size);
  hudLevel.textContent = String(level);
  hudSize.textContent = `${size}×${size}`;
  state.finished = false;
  draw();
  startTimer();
}

/* UI actions */
playBtn.addEventListener('click', (e)=>{
  // Play is a user gesture -> we can start audio safely
  try{ bgm.volume = 0.45; bgm.play().catch(()=>{}); } catch(e){}
  landing.style.display = 'none';
  gameScreen.hidden = false;
  const level = parseInt(levelSelect.value) || 1;
  startLevel(level);
});

document.querySelectorAll('.dpad button').forEach(b=>{
  b.addEventListener('click', ()=> move(b.dataset.dir));
  b.addEventListener('pointerdown', ()=> b.classList.add('active'));
  b.addEventListener('pointerup', ()=> b.classList.remove('active'));
  b.addEventListener('pointerleave', ()=> b.classList.remove('active'));
});

window.addEventListener('keydown', (e)=>{
  const keymap = {ArrowUp:'up', ArrowDown:'down', ArrowLeft:'left', ArrowRight:'right', w:'up', a:'left', s:'down', d:'right'};
  const dir = keymap[e.key];
  if(dir){ e.preventDefault(); move(dir); }
});

/* restart & exit & win modal actions */
btnRestart.addEventListener('click', ()=> startLevel(state.level));
btnExit.addEventListener('click', ()=> {
  // stop & go back to landing
  try{ bgm.pause(); } catch(e){}
  gameScreen.hidden = true;
  landing.style.display = '';
  winModal.style.display = 'none';
});

btnPlayAgain.addEventListener('click', ()=> {
  winModal.style.display = 'none';
  // restart same level
  try{ bgm.currentTime = 0; bgm.play().catch(()=>{}); } catch(e){}
  startLevel(state.level);
});
btnCloseWin.addEventListener('click', ()=> { winModal.style.display='none'; });

/* Responsive: recalc canvas on resize */
window.addEventListener('resize', ()=>{
  if(!gameScreen.hidden){
    setCanvasSize(state.cols, state.rows);
    draw();
  }
});

/* Accessibility: hide dpad if user wants keyboard only? (left as visible) */

/* End of script */
</script>
</body>
</html>
